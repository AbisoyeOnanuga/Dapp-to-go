var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'fs';
import path from 'path';
import { execute } from '../utils/executer.js';
const deleteCache = (projectPath) => {
    const cachePath = path.join(projectPath, 'cache');
    if (fs.existsSync(cachePath)) {
        fs.rmSync(cachePath, { recursive: true, force: true });
    }
    const artifactsPath = path.join(projectPath, 'artifacts');
    if (fs.existsSync(artifactsPath)) {
        fs.rmSync(artifactsPath, { recursive: true, force: true });
    }
};
const checkContracts = (projectPath) => {
    const contractsPath = path.join(projectPath, 'contracts');
    if (!fs.existsSync(contractsPath)) {
        throw new Error('No contracts folder found. Please run this command in the root of your project.');
    }
};
const checkArtifacts = (projectPath) => {
    const artifactsPath = path.join(projectPath, 'artifacts');
    let count = 0;
    const countJsonFiles = (dir) => {
        const files = fs.readdirSync(dir);
        for (let i = 0; i < files.length; i++) {
            const filename = path.join(dir, files[i]);
            const stat = fs.lstatSync(filename);
            if (stat.isDirectory()) {
                countJsonFiles(filename); // Recursive call for directories
            }
            else if (filename.endsWith('.json') &&
                !filename.endsWith('.dbg.json')) {
                // Only count .json files in directories ending with .sol
                if (path.basename(path.dirname(filename)).endsWith('.sol')) {
                    count++;
                }
            }
        }
    };
    countJsonFiles(artifactsPath);
    return count;
};
const compile = (projectPath) => __awaiter(void 0, void 0, void 0, function* () {
    const hardhatConfigPath = path.join(projectPath, 'hardhat.config.js');
    if (!fs.existsSync(hardhatConfigPath)) {
        throw new Error('Hardhat is required to proceed. Please initiate a project using `bunzz clone`');
    }
    try {
        yield execute(`npx hardhat compile`, projectPath, {
            log: false,
            cwd: projectPath,
        });
    }
    catch (e) {
        const errorLines = e.message.split('\n').filter((line) => {
            return (!line.includes('--stack') ||
                !line.includes('--verbose') ||
                !line.includes('https'));
        });
        throw new Error(errorLines.join('\n'));
    }
});
const main = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const projectPath = path.resolve(options.path || process.cwd());
    console.log(`Compiling all smart contracts at ${projectPath}`);
    try {
        deleteCache(projectPath);
        checkContracts(projectPath);
        yield compile(projectPath);
        const compiledContracts = checkArtifacts(projectPath);
        console.log(`Compiled ${compiledContracts} contract${compiledContracts > 1 ? 's' : ''}.`);
        // Please run `bunzz deploy` to deploy this contract (after bunzz build)
        console.log(`Please run \`bunzz deploy\` to deploy this contract.`);
    }
    catch (e) {
        console.error(e.message);
    }
});
export default main;
//# sourceMappingURL=build.js.map